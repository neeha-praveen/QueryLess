// controllers/agentController.js
const axios = require("axios");
const pool = require("../config/pgClient");

/**
 * Utility: ensure schemaName is safe (only lowercase letters, numbers and underscores).
 * Schema names are generated by your backend; this prevents injection if a bad value is provided.
 */
function isValidSchemaName(name) {
  return typeof name === "string" && /^[a-z0-9_]+$/.test(name);
}

/**
 * Check whether the schema exists in Postgres
 */
async function schemaExists(schemaName) {
  const result = await pool.query(
    `SELECT schema_name FROM information_schema.schemata WHERE schema_name = $1`,
    [schemaName]
  );
  return result.rowCount > 0;
}

/**
 * Retrieve table -> column list for a schema
 */
async function getSchemaMetadata(schemaName) {
  const tablesRes = await pool.query(
    `
    SELECT table_name, column_name
    FROM information_schema.columns
    WHERE table_schema = $1
    ORDER BY table_name, ordinal_position
    `,
    [schemaName]
  );

  const structure = {};
  for (const row of tablesRes.rows) {
    structure[row.table_name] = structure[row.table_name] || [];
    structure[row.table_name].push(row.column_name);
  }
  return structure;
}

/**
 * Basic dangerous SQL heuristic (expand as needed)
 */
function isDangerousSQL(sql) {
  if (!sql) return true;
  const lowered = sql.toLowerCase();
  if (lowered.includes("drop table")) return true;
  if (lowered.includes("drop schema")) return true;
  if (lowered.includes("truncate")) return true;
  if (lowered.includes("delete") && !/\bwhere\b/i.test(lowered)) return true;
  return false;
}

/**
 * Try to extract SQL from multiple possible LLM outputs:
 * - fenced ```sql ... ```
 * - plain single SQL statement (SELECT/INSERT/UPDATE/DELETE ... ;)
 * - concatenated streamed chunks (JSON lines)
 */
function extractSqlFromAgentOutput(raw) {
  if (!raw) return null;

  // If the raw is an array/object already, try to find content fields
  if (Array.isArray(raw)) {
    raw = raw.join("\n");
  } else if (typeof raw === "object") {
    // very defensive: try common shapes
    const maybe =
      raw?.message?.content ?? raw?.response ?? raw?.content ?? JSON.stringify(raw);
    raw = maybe;
  }

  // raw is string now (maybe JSON-lines)
  // If it's a newline-separated stream of JSON objects from Ollama, try to parse them
  if (raw.includes("\n")) {
    const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);
    // try to parse each line as JSON and accumulate message.content
    const parts = [];
    for (const line of lines) {
      try {
        const j = JSON.parse(line);
        if (j?.message?.content) parts.push(j.message.content);
        else if (j?.response) parts.push(j.response);
        else if (typeof j === "string") parts.push(j);
      } catch (e) {
        // not JSON — keep original line
        parts.push(line);
      }
    }
    raw = parts.join("");
  }

  // 1) Primary: fenced SQL
  const fenced = raw.match(/```sql([\s\S]*?)```/i);
  if (fenced) return fenced[1].trim();

  // 2) fallback: look for first full statement (SELECT/INSERT/UPDATE/DELETE ... ;)
  const plain = raw.match(/(select|insert|update|delete)[\s\S]*?;/i);
  if (plain) return plain[0].trim();

  // 3) last fallback: try to return the whole string if it looks like SQL-ish
  if (/(select|insert|update|delete)\s+/i.test(raw)) {
    return raw.trim();
  }

  return null;
}

/**
 * Word-boundary check for table/column presence to reduce false positives.
 * returns true if any column appears as a whole word in the SQL.
 */
function containsColumn(sql, col) {
  const re = new RegExp(`\\b${col.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\b`, "i");
  return re.test(sql);
}

/**
 * Main agent entrypoint
 */
exports.runAgent = async (req, res) => {
  try {
    const { message, schemaName } = req.body;

    if (!message || !schemaName) {
      return res.status(400).json({ error: "Missing message or schemaName" });
    }

    if (!isValidSchemaName(schemaName)) {
      return res.status(400).json({ error: "Invalid schemaName format" });
    }

    // Verify schema exists
    const exists = await schemaExists(schemaName);
    if (!exists) {
      return res.status(400).json({ error: `Schema "${schemaName}" does not exist in PostgreSQL` });
    }

    // Get metadata for validation
    const schemaMetadata = await getSchemaMetadata(schemaName);

    // 1) RAG context
    let ragRes;
    try {
      ragRes = await axios.post(
        "http://localhost:4000/api/vector/search",
        { query: message, topK: 5 },
        { headers: { Authorization: req.header("Authorization") }, timeout: 30000 }
      );
    } catch (e) {
      // bubble vector errors clearly
      console.error("RAG error:", e?.message || e);
      return res.status(502).json({ error: "RAG retrieval failed", details: e?.message || String(e) });
    }

    const ragContext = (ragRes.data?.results || [])
      .map(r => `• ${r.content}`)
      .join("\n");

    // 2) System prompt (strict, but short)
    // NOTE: this prompt forces fenced SQL output but we also include fallbacks below.
    const systemPrompt = `
You are QueryLess Autonomous SQL Agent.
Only produce a PostgreSQL SQL statement enclosed exactly inside triple backticks and the token "sql", e.g.:

\`\`\`sql
INSERT INTO employees (first_name, salary) VALUES ('Rahul', 75000);
\`\`\`

Rules:
- Use ONLY the schema: "${schemaName}".
- Use ONLY these existing tables/columns (exact names):
${Object.entries(schemaMetadata).map(([t, cols]) => `  • ${t}: ${cols.join(", ")}`).join("\n")}
- Do NOT invent new columns or tables.
- Do NOT output any explanation or text outside the fenced SQL code block.
- If the request cannot be completed with SQL, respond ONLY with: NOT_SQL

Context (from DB documents):
${ragContext}
`.trim();

    // 3) Ask Ollama (primary attempt)
    let llmResponse;
    try {
      const llmRes = await axios.post(
        "http://localhost:11434/api/chat",
        {
          model: "llama3",
          stream: false,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: message }
          ]
        },
        { timeout: 180000 } // 3 minutes for tough prompts
      );

      // Accept multiple possible keys
      llmResponse = llmRes.data;
    } catch (e) {
      console.error("LLM call error:", e?.message || e);
      return res.status(503).json({ error: "LLM request failed", details: e?.message || String(e) });
    }

    // Convert whatever LLM returned into a single text blob
    const rawText =
      (typeof llmResponse === "string" && llmResponse) ||
      llmResponse?.message?.content ||
      llmResponse?.response ||
      llmResponse?.content ||
      // If it's a stream output saved as a string (many lines), join as-is:
      (typeof llmResponse === "object" ? JSON.stringify(llmResponse) : "");

    if (!rawText) {
      return res.status(500).json({ error: "LLM returned unexpected format", raw: llmResponse });
    }

    if (rawText.trim() === "NOT_SQL") {
      return res.json({ answer: "User request cannot be handled using SQL.", raw: rawText });
    }

    // 4) Extract SQL (fenced preferred, fallback to plain)
    let sql = extractSqlFromAgentOutput(rawText);

    // If no SQL found -> try a small second attempt where we remind the model to only output fenced SQL
    if (!sql) {
      console.warn("No SQL extracted from first LLM output; asking for a strict fenced SQL reply (repair attempt).");
      try {
        const repairRes = await axios.post(
          "http://localhost:11434/api/chat",
          {
            model: "llama3",
            stream: false,
            messages: [
              { role: "system", content: "You MUST now output ONLY the SQL inside triple backticks with 'sql' (no other text)." },
              { role: "user", content: `Previous output:\n${rawText}\n\nPlease output ONLY the SQL in this format:\n\`\`\`sql\n<SQL here>\n\`\`\`` }
            ]
          },
          { timeout: 90000 }
        );

        const repRaw = repairRes.data?.message?.content || repairRes.data?.response || JSON.stringify(repairRes.data);
        sql = extractSqlFromAgentOutput(repRaw);
      } catch (e) {
        console.error("LLM repair attempt failed:", e?.message || e);
        // fall through to return error below
      }
    }

    if (!sql) {
      return res.json({ answer: "LLM did not return SQL in fenced format.", raw: rawText });
    }

    // 5) Safety checks
    if (isDangerousSQL(sql)) {
      return res.status(400).json({ error: "Blocked dangerous SQL", sql });
    }

    // 6) Validate that SQL references existing tables and columns
    const knownTables = Object.keys(schemaMetadata);
    const usedTables = knownTables.filter(t => new RegExp(`\\b${t}\\b`, "i").test(sql));

    if (usedTables.length === 0) {
      return res.status(400).json({ error: "SQL references unknown tables", sql, knownTables });
    }

    // Ensure columns used are present (at least partial check)
    const columnProblems = [];
    for (const t of usedTables) {
      const cols = schemaMetadata[t] || [];
      // find words that look like identifiers in the SQL and check if they match known columns
      // Simple approach: for each known column ensure it's not referenced incorrectly - but we only warn if no known columns appear
      const anyKnown = cols.some(c => containsColumn(sql, c));
      if (!anyKnown) {
        columnProblems.push({ table: t, knownColumns: cols });
      }
    }

    if (columnProblems.length > 0) {
      // don't completely block; surface as a warning but allow execution attempt (or you can choose to block)
      console.warn("Column mismatch warning:", columnProblems);
    }

    // 7) Execute SQL inside the schema search_path - ensure schemaName is safe validated earlier
    try {
      // set search_path then execute sql; using two separate queries helps debugging
      await pool.query(`SET search_path TO ${schemaName};`);
      const result = await pool.query(sql);
      return res.json({
        answer: "Query executed",
        sql,
        rows: result.rows || [],
        rowCount: result.rowCount ?? 0,
        warnings: columnProblems.length ? columnProblems : undefined,
        contextUsed: ragRes.data?.results || []
      });
    } catch (sqlErr) {
      console.error("SQL execution error:", sqlErr?.message || sqlErr);

      // One repair attempt: ask LLM to fix SQL using the error message
      try {
        const fixRes = await axios.post(
          "http://localhost:11434/api/chat",
          {
            model: "llama3",
            stream: false,
            messages: [
              { role: "system", content: "You are a SQL fixer. Output ONLY the corrected SQL inside ```sql ... ```." },
              { role: "user", content: `Original SQL:\n${sql}\n\nError:\n${sqlErr.message}\n\nPlease output only a corrected SQL statement in fenced code block.` }
            ]
          },
          { timeout: 90000 }
        );

        const fixRaw = fixRes.data?.message?.content || fixRes.data?.response || JSON.stringify(fixRes.data);
        const fixedSql = extractSqlFromAgentOutput(fixRaw);

        return res.json({
          answer: "SQL failed; provided repaired SQL (not executed)",
          originalSQL: sql,
          error: sqlErr.message,
          fixedSQL: fixedSql || null,
          fixRaw
        });
      } catch (fixErr) {
        console.error("SQL fix attempt failed:", fixErr?.message || fixErr);
        return res.status(500).json({
          error: "SQL execution failed and repair attempt failed",
          sql,
          details: sqlErr?.message || String(sqlErr)
        });
      }
    }
  } catch (err) {
    console.error("AGENT ERROR RAW:", err);
    return res.status(500).json({
      error: "Agent failed",
      details: err?.message || "no message",
      stack: err?.stack || "no stack"
    });
  }
};
